{{- /* Store tag name from iteration node */}}
{{- $tag := .Node.Name | toGoPascalCase }}
{{- /* Store a list of operations matching this tag */}}
{{- $ops := list }}
{{- range $path, $pathObj := .Doc.Paths }}
  {{- range $method, $op := $pathObj.AsMap }}
    {{- if eq (get $op.Extensions "x-go-primary-tag") $.Node.Name }}
      {{- $ops = append $ops $op}}
      {{- /* Store parent method and echo-format path on the operation */}}
      {{- $_ := set $op.Extensions "x-echo-method" ($method | upper) }}
      {{- $_ := set $op.Extensions "x-echo-path" (include "echo-path" $path) }}
    {{- end }}
  {{- end }}
{{- end }}
{{- /* Process operations to simplify later template logic */}}
{{- range $ops }}
  {{- $op := . }}
  {{- $path := get .Extensions "x-echo-path" }}
  {{- $method := get .Extensions "x-echo-method" }}
  {{- /* Store the requestBody struct type and required against the operation */}}
  {{- with .RequestBody }}
    {{- with .Value }}
      {{- $_ := set $op.Extensions "x-request-body-required" .Required }}
      {{- range $mime, $mto := .Content }}
        {{- if eq $mime "application/json" }}
          {{- with $mto }}
            {{- with .Schema }}
              {{- with .Ref }}
                {{- $_ := set $op.Extensions "x-request-body-type" (include "ref-target-name" .) }}
              {{- end }}
            {{- end }}
          {{- end }}
        {{- else }}
          {{- warnf "Unhandled MIME type %s for requestBody %s:%s" (list $mime $method $path) }}
        {{- end }}
      {{- end }}
    {{- end }}
  {{- end }}
  {{- /* Find a 2xx JSON response with a $ref to a schema type */}}
  {{- range $status, $response := .Responses }}
    {{- if hasPrefix "2" $status }}
      {{- $_ := set $op.Extensions "x-response-status" $status }}
      {{- with .Value }}
        {{- range $mime, $mto := .Content }}
          {{- if eq $mime "application/json" }}
            {{- with $mto }}
              {{- with .Schema }}
                {{- with .Ref }}
                  {{- $_ := set $op.Extensions "x-response-body-type" (include "ref-target-name" .) }}
                {{- end }}
              {{- end }}
            {{- end }}
          {{- else }}
            {{- warnf "Unhandled MIME type %s for reponse %s:%s code %s" (list $mime $method $path $status) }}
          {{- end }}
        {{- end }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}
{{- /* End of header */}}
// Code generated by goapi. DO NOT EDIT.
{{ include "package" . }}

import (
  "net/http"
  "regexp"
  "strings"

  "github.com/labstack/echo/v4"
  "github.com/go-playground/validator/v10"
)

// Interface for {{ $tag }} route endpoints
type {{ $tag }}Endpoints interface {
  {{- range $ops }}
  {{- with .Description }}

  // {{ . }}
  {{- end }}
  {{ include "operation-wrapper-name" . }}({{ include "operation-args" . }}) {{ include "operation-return" . }}
  {{- end }}
}

// Wrapper to expose {{ $tag }}Endpoints functions as echo handlers/middleware
type {{ $tag }}RouteHandlers struct {
  validate *validator.Validate
  wrapper {{ $tag }}Endpoints
}

func New{{ $tag }}RouteHandlers(wrapper {{ $tag }}Endpoints) *{{ $tag }}RouteHandlers {
  return &{{ $tag }}RouteHandlers{
    validate: validator.New(validator.WithRequiredStructEnabled()),
    wrapper: wrapper,
  }
}

{{- range $ops }}
{{- $op := . }}
{{- $handler := include "operation-handler-name" . }}
{{- $middleware := include "operation-middleware-name" . }}
{{- $wrapper := include "operation-wrapper-name" . }}
{{- $getPath := include "operation-path-name" . }}
{{- $method := get .Extensions "x-echo-method" }}
{{- $path := get .Extensions "x-echo-path" }}

//------------------------------------------------------------------------------
// # {{ $op.OperationID }}{{ with $op.Summary }}: {{ . }}{{ end }}
//
// {{ $method }}:{{ $path }}
{{- with $op.Description }}
//
{{ . | wrap 77 | comment "//" }}
{{- end }}
{{- with $op.Security }}
//
// ## Security
//
{{- range . }}
{{- if eq 0 (len .) }}
// - public
{{- else }}
{{- range $k, $v := . }}
// - {{ $k }}{{ with $v }}: {{ . | join ", " }}{{ end }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}
{{- with $op.Parameters }}
//
// ## Parameters
//
{{ . | yaml | trim | comment "//" }}
{{- end }}
{{- with $op.RequestBody }}
//
// ## Request Body
//
{{ . | yaml | trim | comment "//" }}
{{- end }}
{{- with $op.Responses }}
//
// ## Responses
//
{{ . | yaml | trim | comment "//" }}
{{- end }}
//------------------------------------------------------------------------------

// Validate requests to {{ $method }}:{{ $path }}
func (r *{{ $tag }}RouteHandlers) {{ $middleware }}(next echo.HandlerFunc) echo.HandlerFunc {
  return func(c echo.Context) error {
    {{- range .Security }}
    {{- if eq 0 (len .) }}
    c.Set("security.public", []string{})
    {{- else }}
    {{- range $key, $sec := . }}
    {{- $v := list }}
    {{- range $sec }}{{ $v = append $v (. | quote) }}{{ end }}
    c.Set("security.{{ $key | toSnakeCase }}", {{ join "" (list "[]string{" ($v | join ", ") "}") }})
    {{- end }}
    {{ end }}
    {{- end }}

    {{- range .Parameters }}
    {{- if eq .Value.In "cookie" }}
    {{- include "operation-validate-cookie-param" . }}
    {{ end }}
    {{- end }}

    {{- range .Parameters }}
    {{- if eq .Value.In "header" }}
    {{- include "operation-validate-header-param" . }}
    {{ end }}
    {{- end }}

    {{- range .Parameters }}
    {{- if eq .Value.In "path" }}
    {{- include "operation-validate-path-param" . }}
    {{ end }}
    {{- end }}

    {{- include "operation-validate-request-query" . }}
    {{- include "operation-validate-request-body" . }}
    return next(c)
  }
}

// Handle requests to {{ $method }}:{{ $path }}
func (r *{{ $tag }}RouteHandlers) {{ $handler }}(c echo.Context) error {
  {{- $args := list "c" }}

  {{- range .Parameters }}
  {{- if eq .Value.In "cookie" }}
  {{- $var := include "param-arg-name" . }}
  {{ $var }} := c.Get("param.{{ .Value.Name | toSnakeCase }}").(string)
  {{- $args = append $args $var }}
  {{- end }}
  {{- end }}

  {{- range .Parameters }}
  {{- if eq .Value.In "header" }}
  {{- $var := include "param-arg-name" . }}
  {{ $var }} := c.Get("param.{{ .Value.Name | toSnakeCase }}").(string)
  {{- $args = append $args $var }}
  {{- end }}
  {{- end }}

  {{- range .Parameters }}
  {{- if eq .Value.In "path" }}
  {{- $var := include "param-arg-name" . }}
  {{ $var }} := c.Get("param.{{ .Value.Name | toSnakeCase }}").(string)
  {{- $args = append $args $var }}
  {{- end }}
  {{- end }}

  {{- with get .Extensions "x-request-body-type" }}
  body := c.Get("body").(*{{ . }})
  {{- $args = append $args "body" }}
  {{- end }}

  {{- with get .Extensions "x-goapi-query-object" }}
  query := c.Get("query").(*{{ . }})
  {{- $args = append $args "query" }}
  {{- end }}
  {{ with get .Extensions "x-response-body-type" }}
  if res, err := r.wrapper.{{ $wrapper }}({{ $args | join ", " }}); err == nil {
    if !c.Response().Committed {
      {{- with get $op.Extensions "x-response-status" }}
      return c.JSON({{ . }}, res)
      {{- else }}
      return c.JSON(http.StatusOK, res)
      {{- end }}
    } else {
      return nil
    }
  } else {
    return err
  }
  {{- else }}
  if err := r.wrapper.{{ $wrapper }}({{ $args | join ", " }}); err == nil {
    if !c.Response().Committed {
      {{- with get $op.Extensions "x-response-status" }}
      return c.NoContent({{ . }})
      {{- else }}
      return c.NoContent(http.StatusNoContent)
      {{- end }}
    } else {
      return nil
    }
  } else {
    return err
  }
  {{- end }}
}

// Get path for {{ $method }}:{{ $path }}
func (r *{{ $tag }}RouteHandlers) {{ $getPath }}(trimPrefix ...string) string {
  if len(trimPrefix) > 0 {
    return strings.TrimPrefix({{ $path | quote }}, trimPrefix[0])
  }
  return {{ $path | quote }}
}

// Register the handler and middleware for {{ $method }}:{{ $path }} at the default path
func (r *{{ $tag }}RouteHandlers) Register{{ $wrapper }}Route(e EchoLike, m ...echo.MiddlewareFunc) *echo.Route {
  return r.Register{{ $wrapper }}RouteAt(r.{{ $getPath }}(), e, m...)
}

// Register the handler and middleware for {{ $method }}:{{ $path }} at a custom path
func (r *{{ $tag }}RouteHandlers) Register{{ $wrapper }}RouteAt(path string, e EchoLike, m ...echo.MiddlewareFunc) *echo.Route {
  mw := append([]echo.MiddlewareFunc{r.{{ $middleware }}}, m...)
  return e.{{ $method }}(path, r.{{ $handler }}, mw...)
}

{{- end }}
