{{- /* Store tag name from iteration node */}}
{{- $tag := .Node.Name | toGoPascalCase }}
{{- /* Store a list of operations matching this tag */}}
{{- $ops := list }}
{{- range $path, $pathObj := .Doc.Paths }}
  {{- range $method, $op := $pathObj.AsMap }}
    {{- if eq (get $op.Extensions "x-go-primary-tag") $.Node.Name }}
      {{- $ops = append $ops $op}}
      {{- /* Store parent method and echo-format path on the operation */}}
      {{- $_ := set $op.Extensions "x-echo-method" ($method | upper) }}
      {{- $_ := set $op.Extensions "x-echo-path" (include "echo-path" $path) }}
    {{- end }}
    {{- /* Store the requestBody struct type and required against the operation */}}
    {{- with .RequestBody }}
      {{- with .Value }}
        {{- $_ := set $op.Extensions "x-request-body-required" .Required }}
        {{- range $mime, $mto := .Content }}
          {{- if eq $mime "application/json" }}
            {{- with $mto }}
              {{- with .Schema }}
                {{- with .Ref }}
                  {{- $_ := set $op.Extensions "x-request-body-type" (include "ref-target-name" .) }}
                {{- end }}
              {{- end }}
            {{- end }}
          {{- else }}
            {{- warnf "Unhandled MIME type %s for requestBody %s:%s" (list $mime $method $path) }}
          {{- end }}
        {{- end }}
      {{- end }}
    {{- end }}
    {{- /* Find a 2xx JSON response with a $ref to a schema type */}}
    {{- range $status, $response := .Responses }}
      {{- if hasPrefix "2" $status }}
        {{- $_ := set $op.Extensions "x-response-status" $status }}
        {{- with .Value }}
          {{- range $mime, $mto := .Content }}
            {{- if eq $mime "application/json" }}
              {{- with $mto }}
                {{- with .Schema }}
                  {{- with .Ref }}
                    {{- $_ := set $op.Extensions "x-response-body-type" (include "ref-target-name" .) }}
                  {{- end }}
                {{- end }}
              {{- end }}
            {{- else }}
              {{- warnf "Unhandled MIME type %s for reponse %s:%s code %s" (list $mime $method $path $status) }}
            {{- end }}
          {{- end }}
        {{- end }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}
{{- /* End of header */}}
// Code generated by goapi. DO NOT EDIT.
{{ include "package" . }}

import (
  "http"
  "regexp"

  "github.com/labstack/echo/v4"
  "github.com/go-playground/validator/v10"
)

type {{ $tag }}Path string

const (
  {{- range $ops }}
  {{ include "operation-path-name" . }} {{ $tag }}Path = {{ get .Extensions "x-echo-path" | quote }}
  {{- end }}
)

// Interface for {{ $tag }} route endpoints
type {{ $tag }}Endpoints interface {
  {{- range $ops }}
  {{ include "operation-wrapper-name" . }}({{ include "operation-args" . }}) {{ include "operation-return" . }}
  {{- end }}
}

// Wrapper to expose {{ $tag }}Endpoints functions as echo handlers/middleware
type {{ $tag }}RouteHandlers struct {
  validate *validator.Validate
  wrapper {{ $tag }}Endpoints
}

func New{{ $tag }}RouteHandlers(wrapper {{ $tag }}Endpoints) *{{ $tag }}RouteHandlers {
  return &{{ $tag }}RouteHandlers{
    validate: validator.New(validator.WithRequiredStructEnabled()),
    wrapper: wrapper,
  }
}

{{- range $ops }}
{{- $op := . }}
{{- $handler := include "operation-handler-name" . }}
{{- $middleware := include "operation-middleware-name" . }}
{{- $wrapper := include "operation-wrapper-name" . }}
{{- $method := get .Extensions "x-echo-method" }}
{{- $path := get .Extensions "x-echo-path" }}

// Validate requests to {{ $method }}:{{ $path }}
func (r *{{ $tag }}RouteHandlers) {{ $middleware }}(next echo.HandlerFunc) echo.HandlerFunc {
  return func(c echo.Context) error {
    {{- range .Parameters }}
    {{- if eq .Value.In "path" }}
    {{- include "operation-validate-path-param" . }}
    {{ end }}
    {{- end }}

    {{- include "operation-validate-request-query" . }}
    {{- include "operation-validate-request-body" . }}
    return next(c)
  }
}

// Handle requests to {{ $method }}:{{ $path }}
func (r *{{ $tag }}RouteHandlers) {{ $handler }}(c echo.Context) error {
  {{- $args := list "c" }}
  {{- range .Parameters }}
  {{- if eq .Value.In "path" }}
  {{- $var := include "param-arg-name" . }}
  {{ $var }} := c.Get("param.{{ .Value.Name }}").(string)
  {{- $args = append $args $var }}
  {{- end }}
  {{- end }}

  {{- with get .Extensions "x-request-body-type" }}
  body := c.Get("body").(*{{ . }})
  {{- $args = append $args "body" }}
  {{- end }}

  {{- with get .Extensions "x-goapi-query-object" }}
  query := c.Get("query").(*{{ . }})
  {{- $args = append $args "query" }}
  {{- end }}
  {{ with get .Extensions "x-response-body-type" }}
  if res, err := r.wrapper.{{ $wrapper }}({{ $args | join ", " }}); err == nil {
    {{- with get $op.Extensions "x-response-status" }}
    return c.JSON({{ . }}, res)
    {{- else }}
    return c.JSON(http.StatusOK, res)
    {{- end }}
  } else {
    return err
  }
  {{- else }}
  if err := r.wrapper.{{ $wrapper }}({{ $args | join ", " }}); err == nil {
    {{- with get $op.Extensions "x-response-status" }}
    return c.NoContent({{ . }})
    {{- else }}
    return c.NoContent(http.StatusNoContent, res)
    {{- end }}
  } else {
    return err
  }
  {{- end }}
}

// Register the handler and middleware for {{ $method }}:{{ $path }} at the default path
func (r *{{ $tag }}RouteHandlers) Register{{ $wrapper }}Route(e EchoLike, m ...echo.MiddlewareFunc) *echo.Route {
  return r.Register{{ $wrapper }}RouteAt(e, string({{ include "operation-path-name" . }}), m...)
}

// Register the handler and middleware for {{ $method }}:{{ $path }} at a custom path
func (r *{{ $tag }}RouteHandlers) Register{{ $wrapper }}RouteAt(e EchoLike, path string, m ...echo.MiddlewareFunc) *echo.Route {
  mw := append([]echo.MiddlewareFunc{r.{{ $middleware }}}, m...)
  return e.{{ $method }}(path, r.{{ $handler }}, mw...)
}

{{- end }}
